import os from "os";
import { expect } from "chai";
import open, { Database, DbController } from "./db.js";
import path from "path";
import { fileURLToPath } from 'url';
import Vfs from "../index.js";
import UserManager from "../../auth/UserManager.js";
import errors from "./errors.js";

const thisDir = path.dirname(fileURLToPath(import.meta.url));


describe("Database", function(){

  it("open error handler", async function(){
    await expect(open({uri: "postgres://localhost:5430/foo"})).to.be.rejectedWith("database connect ECONNREFUSED at : postgres://localhost:5430/foo");
  });

  it("open error won't log credentials", async function(){
    await expect(open({uri: "postgres://user:secret@localhost:5430/foo"})).to.be.rejectedWith("database connect ECONNREFUSED at : postgres://***:***@localhost:5430/foo");
  });


  describe("open", function(){
    let db :Database, uri: string;
    this.beforeEach(async function(){
      uri = await getUniqueDb();
      db = await open({
        uri,
        forceMigration: true,
      });
    });

    this.afterEach(async function(){
      await db?.end(); //Otherwise it leaks
    });

    describe("migration", function(){
      //Check if the last migration's UP/DOWN steps can be applied without error
      //Doesn't check much else
      it("over empty database", async function(){
        await db.end();
        //Will fail if migrations can't be reapplied
        //Also tests syntax of the "down" migration.
        db = await open({
          uri,
          forceMigration: true
        });
      });
    
      it("over dummy data", async function(){
        let vfs = new Vfs(os.tmpdir(), db);
        let users = new UserManager(db);
        let user = await users.addUser("bob", "12345678", "create");
        await vfs.createScene("foo");
        // await vfs.writeDoc("{}", {scene: "foo", user_id: 0, name: "test.json", mime: "application/json"});
        // await vfs.removeFile({scene: "foo", name: "test.json", user_id: 0});
        // await vfs.writeDoc(`{"foo": "bar"}`, {scene: "foo", user_id: user.uid, name: "test.json", mime: "application/json"});
        
        await db.end();
        //Will fail if migrations can't be reapplied
        //Also tests syntax of the "down" migration.
        db = await open({
          uri,
          forceMigration: true
        });
      });
    });

    describe("beginTransaction()", function(){
      this.beforeEach(async function(){
        await db.run(`
          CREATE TABLE test (id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, name TEXT UNIQUE);
          INSERT INTO test (name) VALUES ('foo');
        `);
      });

      it("provides isolation to parent db", async function(){
        let p;
        let length = (await db.all(`SELECT * FROM test`)).length
        await expect(db.beginTransaction(async (tr)=>{
          await tr.run(`INSERT INTO test (name) VALUES ($1)`, ["bar"]);
          p = await db.all(`SELECT * FROM test`)
        })).to.be.fulfilled;
        expect(p).to.have.property("length", length);
      });
    
      it("nested transactions reuse the same database instance", async function(){
        let count = 0;
        await expect(db.beginTransaction(async (tr)=>{
          expect(tr).to.not.equal(db);
          await tr.beginTransaction(async tr2=>{
            count++,
            expect(tr2).to.equal(tr);
          })
        })).to.be.fulfilled;
        expect(count).to.equal(1);
        
      });
    
      it("opens and makes a transaction", async function(){
        await expect(db.beginTransaction(async (tr)=>{
          await tr.run(`INSERT INTO test (name) VALUES ('bar')`);
          return await tr.all(`SELECT * FROM test`);
        })).to.eventually.have.property("length", 2);
        await expect(db.all(`SELECT * FROM test`)).to.eventually.have.property("length", 2);
      });
    
      it("rollbacks when an error occurs", async function(){
        await expect(db.beginTransaction(async (tr)=>{
          await tr.run(`INSERT INTO test (name) VALUES ('bar')`);
          await tr.run(`INSERT INTO test (name) VALUES ('foo')`); //UNIQUE VIOLATION
        })).to.be.rejectedWith({code: errors.unique_violation, table: "test", constraint: "test_name_key"} as any);
        
        await expect(db.all(`SELECT * FROM test`)).to.eventually.have.property("length", 1);
      });
    
      it("won't deadlock", async function(){
        await expect(db.beginTransaction(async (tr)=>{
          await tr.all("SELECT * FROM test");
          await tr.run(`INSERT INTO test (name) VALUES ('alice')`);
          await tr.beginTransaction(async tr2=>{
            await tr2.all("SELECT * FROM test");
            await tr2.run(`INSERT INTO test (name) VALUES ('bob')`);
          })
          await tr.all("SELECT * FROM test");
          await tr.run(`INSERT INTO test (name) VALUES ('charlie')`)
        })).to.be.fulfilled;
      });
    
      it("rollback unwraps properly from within", async function(){
        let exp = [
          {id: 1, name: "foo"},
          {id: 2, name: "alice"},
          {id: 3, name: "bob"}
        ]
        await expect(db.beginTransaction(async (tr)=>{
          await tr.run(`INSERT INTO test (name) VALUES ('alice')`);
          await expect(tr.beginTransaction(async tr2=>{
            await tr2.all("SELECT * FROM test");
            throw new Error("Dummy");
          })).to.be.rejectedWith("Dummy");
          await tr.run(`INSERT INTO test (name) VALUES ('bob')`);
          return await tr.all("SELECT * FROM test");
        })).to.eventually.deep.equal(exp);
    
        expect(await db.all("SELECT * FROM test"), `changes should not be rolled back`).to.deep.equal(exp);
    
      })
    });
    
  })
});


describe("DbController", function(){
    let db :Database, uri: string;
    this.beforeEach(async function(){
      uri = await getUniqueDb();
      db = await open({
        uri,
        forceMigration: true,
      });
    });

    this.afterEach(async function(){
      await db?.end(); //Otherwise it leaks
    });

    describe("multi-controller isolate", function(){
      let c1 :DbController, c2: DbController;

      this.beforeEach(async function(){
        await db.run("CREATE TABLE test (value TEXT)");
        await db.run("INSERT INTO test VALUES ('foo')")
        c1 = new DbController(db);
        c2 = new DbController(db);
      })

      it("test failure mode", async function(){
        let values_c1:number, values_c2: number;
        //Check if our test case reliably fails when isolate doesn't work as intended
        await c1.isolate(async (t1)=>{
          //This will not be visible outside of the transaction before comitted
          await t1._db.run("INSERT INTO test VALUES ('bar')")
          values_c1 = (await t1._db.get<{count:number}>("SELECT COUNT(*) as count FROM test")).count; 
          values_c2 = (await c2._db.get<{count:number}>("SELECT COUNT(*) as count FROM test")).count; 
        });
        expect(values_c1!, "added value should be visible in the transaction").to.equal(2);
        expect(values_c2!, "added value should not be visible for non-isolated controllers").to.equal(1);
      });

      it("test nested isolation", async function(){
        let values_t1:number, values_t2: number, values_c1: number;
        //Check if our test case reliably fails when isolate doesn't work as intended
        await c1.isolate(async (t1)=>{
          await c2.isolate(t1, async (t2)=>{
            //This will not be visible in the transaction
            await t1._db.run("INSERT INTO test VALUES ('bar')");
            await t2._db.run("INSERT INTO test VALUES ('baz')");
            values_t1 = (await t1._db.get<{count:number}>("SELECT COUNT(*) as count FROM test")).count; 
            values_t2 = (await t2._db.get<{count:number}>("SELECT COUNT(*) as count FROM test")).count;
            values_c1 = (await c1._db.get<{count:number}>("SELECT COUNT(*) as count FROM test")).count;

            await t2._db.run("INSERT INTO test VALUES ('bazz')");
          })
        });
        expect(values_t1!, "added value should be visible in the transaction").to.equal(3);
        expect(values_t2!, "added value should be visible in the transaction").to.equal(3);
        expect(values_c1!, "added value should not be visible outside of the transaction").to.equal(1);
        expect((await db.get<{count:number}>("SELECT COUNT(*) as count FROM test")).count, "after transaction, all values should exist").to.equal(4);
      });
    })


});